<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Everyday ECMAScript 6</title>

    <meta name="description" content="">
    <meta name="author" content="Trey Hunner">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Everyday ECMAScript 6</h1>
          <p>
            <small><a href="http://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            My name is Trey.  I am a web consultant, open source advocate, and I also teach front-end web development.

            Today I'm going to tell you about some new JavaScript features you can use to make your code much more readable.
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <h2>ECMAScript 2015 (ES2015)</h2>
          <p>
            <ul>
              <li>Also known as ECMAScript 6 (ES6)</li>
              <li><a href="http://www.ecma-international.org/ecma-262/6.0/">Specification</a> finalized June 2015</li>
              <li class="fragment" data-fragment-index="1">Fully-supported in 0 browsers</li>
            </ul>
          </p>
          <aside class="notes" data-markdown>
            ECMAScript is the official name of the JavaScript language specification.  ECMAScript 5 was finalized 5 years ago and is entirely supported in all modern browsers.

            The next version, ECMAScript 6 has been a long time coming, but it was finally released last month.

            Earlier this year, ES6 was renamed to ECMAScript 2015.  What was called ECMAScript 7 will most likely be called ECMAScript 2016.  So hopefully, we won't need to wait another 5 years for more features.  During this talk I will be using the terms ECMAScript 2015 and ECMAScript 6 interchangeably.

            This new language specification was just finalized last month but it is already fully supported in all major browsers.

            Oh wait, no.  I mean it's not supported in **any** browsers.  It's going to be a long time before you can confidently use this new language in the browser.  Bummer.
          </aside>
        </section>

        <section data-background="#f5da55" data-background-transition="fade" data-transition="zoom-in zoom-out">
          <a href="http://babeljs.io/"><img src="babel-logo.svg" class="no-style"></a>
          <h3>Use next generation JavaScript, today.</h3>
          <aside class="notes" data-markdown>
            But wait! You **can** start using this new language today!  You just need to transpile your code with Babel.

            Babel allows you to compile your ECMAScript 6 code down to ECMAScript 5, which is understood by all modern web browsers.  This JavaScript-to-JavaScript compilation is known as trans-piling.

            So with Babel you can start using the cool new features in ECMAScript 6 today.  But which features should you use?
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
          <h2>ES2015 features to use today</h2>
          <ol>
            <li>template strings</li>
            <li>object methods</li>
            <li>fat arrow functions</li>
            <li>let declarations</li>
            <li>for..of</li>
            <li>destructuring</li>
          </ol>
          <aside class="notes" data-markdown>
            There are a lot of cool features in ES6, but I'm going to talk about just 6 of them today.
          </aside>
        </section>

        <section>
          <h2>Template Strings</h2>
          <p>
            <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
var pageNumber = "( " + getCount() + " / " + pageTotal + " )";
            </code></pre>
          </p>
          <p>
            <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
var pageNumber = `( ${getCount()} / ${pageTotal} )`;
            </code></pre>
          </p>
          <aside class="notes" data-markdown>
            If you have ever tried to stick a variable inside a string in JavaScript, you'll know it requires concatenation.  Look at all those plus signs and quotes.

            With template strings, you can include your variables right inside your string.  Just use backticks and you've made a template string.
          </aside>
          <!--
          <section>
            <h2>Template Strings</h2>
            <p>
              <pre class="fragment javascript" data-fragment-index="1"><code data-trim>
var poem = [
  "JavaScript = fun",
  "Uncaught ReferenceError",
  "fun is not defined"
].join("\n");

              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
var poem = `JavaScript = fun
Uncaught ReferenceError
help is not defined`;

              </code></pre>
            </p>
            <aside class="notes" data-markdown>
              Template strings also support multi-line strings.

              Previously you may have used string concatenation or the Array `join` method to make multi-line strings.  Now you can just use template strings.
            </aside>
          </section>
          -->
        </section>

        <section>
          <h2>Methods</h2>
            <p>
              <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
var Duck = Backbone.Model.extend({
  name: function name() {
    return "duck";
  },
  sound: function sound() {
    return "quack";
  }
});
              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
var Duck = Backbone.Model.extend({
  name() {
    return "duck";
  },
  sound() {
    return "quack";
  }
});

              </code></pre>
            </p>
          <aside class="notes" data-markdown>
            If you ever make custom objects in JavaScript, you probably write a lot of code that looks like this.  Most JavaScript MVC frameworks include an object syntax that uses key/value pairs for defining methods and attributes.

            With the new method syntax, you can remove a lot of the syntax cruft when defining methods.

            Notice the lack of the word function.  Also note that the functions in these examples are named.
          </aside>
        </section>

        <section>
          <section>
            <h2>Fat Arrows</h2>
            <p>
              <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
promise.then(function (data) {
  return data.response;
}).display();
              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
promise.then(data => data.response).display();
              </code></pre>
            </p>
            <aside class="notes" data-markdown>
              JavaScript is an event-driven language that loves callback functions.  So one-off anonymous functions are very useful in JavaScript.

              With the new fat arrow syntax, you can define anonymous functions much more elegantly.

              In this example, we've lost the parenthesis, the curly braces, the return statement, and the word function.  This is much shorter.
            </aside>
          </section>
          <section>
            <h2>Fat Arrows</h2>
            <p>
              <pre data-fragment-index="1" class="javascript fragment fade-out display-fragment"><code data-trim>
var self = this;
var getValue = function () {
  return self.value;
});
              </code></pre>
              <pre data-fragment-index="1" class="javascript fragment fade-in display-fragment"><code data-trim>
var getValue = function () {
  return this.value;
}.bind(this));
              </code></pre>
            </p>
            <p>
            <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
var getValue = () => this.value;
              </code></pre>
            </p>
            <aside class="notes" data-markdown>
              Have you ever seen code with "self" variables or "that" variables that are used to store "this"?

              Slight Aside: You shouldn't be using "self" or "that".  The "bind" function was introduced in ECMAScript 5 and it's a bit more idiomatic.

              Anyway, fat arrow functions can replace both of these use cases because they inherit the "this" and "arguments" bindings from their outer scope.

              The syntax looks a little funny, but again, this is much shorter than the old way.
            </aside>
          </section>
          <!--
          <section>
            <h2>Fat Arrows</h2>
            <p>
            <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
events.sort(function (e1, e2) {
  var d1 = new Date(e1.startDate);
  var d2 = new Date(e2.startDate);
  return d1 - d2;
});
              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
events.sort((e1, e2) => {
  var d1 = new Date(e1.startDate);
  var d2 = new Date(e2.startDate);
  return d1 - d2;
});
              </code></pre>
            </p>
          </section>
          -->
        </section>

        <section>
          <h2>Let</h2>
          <p>
            <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
var array = [];
for (var i = 0; i < 10; i++) {
array.push(Math.random());
}
console.log(i);  // Returns 10
            </code></pre>
          </p>
          <p>
            <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
let array = [];
for (let i = 0; i < 10; i++) {
array.push(Math.random());
}
console.log(i);  // ReferenceError: i is not defined
            </code></pre>
          </p>
          <aside class="notes" data-markdown>
            Function hoisting! Variable hoisting! Function-level scoping!  All of these JavaScript idiosyncrasies are now **gone** in ECMAScript 6!  Well sort of...

            In ECMAScript 6 you can use "let" instead of "var" to define your variables. When you do this they'll use block-level scoping and they will not be hoisted to the top of your function.  If you do not know what variable hoisting means, look it up.  It's one of the bad parts of JavaScript.

            When you start using Babel to transpile your code, the first thing you should do is change all of your code to use "let" instead of "var".

            Here's an example of block-scoping with "let".  Notice that "var" leaks variables everywhere because "var" makes variables function-scoped.
          </aside>
        </section>

        <section>
          <section>
            <h3>Destructuring Arrays</h3>
            <p>
              <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
var numbers = [1, 4, 2, 3];
var x = numbers[0];
var y = numbers[1];
var z = numbers[2];
              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
let numbers = [1, 4, 2, 3];
let [x, y, z] = numbers;
              </code></pre>
            </p>
            <aside class="notes" data-markdown>
              If you want to grab a sequence of elements out of an array in JavaScript, you need to write a lot of assignment statements.

              With array destructuring syntax, you can now assign multiple variables to a sequence at once.

              This new syntax can result in code that is much easier to read and much more maintainable.
            </aside>
          </section>
          <section>
            <h3>Destructuring Objects</h3>
            <p>
              <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
var emoji = {category: "people", char: "😁", name: "smile"};
var character = emoji.char;
var name = emoji.name;
var category = emoji.category;
              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
let emoji = {category: "people", char: "😁", name: "smile"};
let {name, category, char: character} = emoji;
              </code></pre>
            </p>
            <aside class="notes" data-markdown>
              We have the same code duplication problem with Object destructing as we have with Array destructuring.

              The new object destructuring syntax allows us to assign multiple variables to the values of multiple attributes on an object.

              If the variable name is different than the object attribute, you need to use a colon to separate the attribute name from the variable name.  This is what we're doing for the "character" attribute and "char" variable in this example.

              If the variable name is the same as the object attribute, you just need to list the name.  This is what we're doing for "name" and "category" in the example.
            </aside>
          </section>
          <section>
            <h3>Destructuring & For..Of</h3>
            <p>
              <pre data-fragment-index="1" class="javascript fragment"><code data-trim>
var coordinates = [{x: 1, y: 4}, {x: 3, y: 3}, {x: 2, y: 2}];
var timesAtHome = 0;
var c;

for (var i = 0; i < coordinates.length; i++) {
  c = coordinates[i];
  if (c.x === 3 && c.y === 3) {
    timesAtHome += 1;
  }
}
              </code></pre>
            </p>
            <p>
              <pre data-fragment-index="2" class="javascript fragment"><code data-trim>
let coordinates = [{x: 1, y: 4}, {x: 3, y: 3}, {x: 2, y: 2}];
let timesAtHome = 0;

for (let {x, y} of coordinates) {
  if (x === 3 && y === 3) {
    timesAtHome += 1;
  }
}
              </code></pre>
            </p>
            <aside class="notes" data-markdown>
              Let's loop through an array of coordinates and count the number of times we visit our home base.  We'll use a variable ``i`` as a counter, starting it at 0, and incrementing it after each loop.  We'll end the looping when ``i`` equals the length of the array.  Each time we loop, we'll assign ``c`` to the ``i``th element of our array.  When ``c.x`` and ``c.y`` are both 3 then we'll increment ``timesAtHome``.

              Let's loop through an array of coordinates and count the number of times we visit our home base.  We'll loop over each element of the array, getting the ``x`` and ``y`` attributes from it.  When ``x`` and ``y`` are both 3 we'll increment ``timesAtHome``.

              This new "for of" syntax, combined with object destructuring, makes our code much shorter.
            </aside>
          </section>
        </section>

        <section data-background="#f5da55" data-background-transition="fade" data-transition="zoom-in zoom-out">
          <h1>Go Forth and Babel</h1>
          <p>Try it out: <a href="http://babeljs.io/repl/">http://babeljs.io/repl</a></p>
          <p><a href="http://trey.in/everyday-es6-code">http://trey.in/everyday-es6-code</a></p>
          <aside class="notes" data-markdown>
            Okay.  I have a mission for you now.

            After you go home tonight I want you all to go to Babel website and try it out.  Type in some code using the new JavaScript syntax and see what it will convert it to.  If you don't have time tonight, try it out this weekend.

            If you want to see how Babel transpiles the ES6 code examples I used in this talk, you can go to trey.in/evereyday-es6-code.

            I will be posting that link and a link to my slides on the meetup event so you don't need to write that down.
          </aside>
        </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h1>Final</h1>
          <p>
          <small><a href="http://trey.in/everyday-es6-code">http://trey.in/everyday-es6-code</a></small>
          </p>
          <p>
            <small><a href="http://treyhunner.com">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <p>
          <small>
            Web consultant available for hire
            <br>
            <a href="http://truthful.technology/">http://truthful.technology</a>
          </small>
          </p>
          <p>
          <img src="logo-text-inverted.svg" class="no-style logo">
          </p>
          <aside class="notes" data-markdown>
            Any questions?
          </aside>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
